import heapq

class Leaderboard:
    def __init__(self):
        self.jogadores = {}
        self.heap_pontuacao = []
    
    def adicionar_jogador(self, id_jogador, nome, pontuacao):
        self.jogadores[id_jogador] = {
            'nome': nome,
            'pontuacao': pontuacao
        }
        heapq.heappush(self.heap_pontuacao, (pontuacao, id_jogador))
    
    def atualizar_pontuacao(self, id_jogador, nova_pontuacao):
        if id_jogador in self.jogadores:
            self.jogadores[id_jogador]['pontuacao'] = nova_pontuacao
            heapq.heappush(self.heap_pontuacao, (nova_pontuacao, id_jogador))
    
    def top_n_jogadores(self, n):
        # Usar um heap m√°ximo (invertendo os valores)
        heap_max = [(-pont, id_jog) for pont, id_jog in self.heap_pontuacao]
        heapq.heapify(heap_max)
        
        top_jogadores = []
        for _ in range(n):
            if not heap_max:
                break
            pont_neg, id_jog = heapq.heappop(heap_max)
            top_jogadores.append((self.jogadores[id_jog]['nome'], -pont_neg))
        
        return top_jogadores
    
    def buscar_jogador(self, nome=None, id_jogador=None):
        if id_jogador:
            return self.jogadores.get(id_jogador)
        if nome:
            for jogador in self.jogadores.values():
                if nome.lower() in jogador['nome'].lower():
                    return jogador
        return None

# Exemplo de uso
if __name__ == "__main__":
    lb = Leaderboard()
    lb.adicionar_jogador(1, "Player1", 2500)
    lb.adicionar_jogador(2, "Player2", 1800)
    lb.adicionar_jogador(3, "Player3", 3200)
    lb.adicionar_jogador(4, "Player4", 2900)
    
    print("Top 3 jogadores:")
    for nome, pontuacao in lb.top_n_jogadores(3):
        print(f"{nome}: {pontuacao}")
    
    print("\nBusca por Player3:")
    jogador = lb.buscar_jogador(nome="Player3")
    print(f"{jogador['nome']} - {jogador['pontuacao']}")
